# üîß –ì–ª—É–±–æ–∫–æ–µ –ü–æ–≥—Ä—É–∂–µ–Ω–∏–µ –≤ –°–∏—Å—Ç–µ–º—É Overrides

## üìã –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ
1. [–í–≤–µ–¥–µ–Ω–∏–µ –≤ Overrides](#-–≤–≤–µ–¥–µ–Ω–∏–µ-–≤-overrides)
2. [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –°–∏—Å—Ç–µ–º—ã Overrides](#-–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-—Å–∏—Å—Ç–µ–º—ã-overrides)
3. [–ú–µ—Ö–∞–Ω–∏–∑–º—ã –°–ª–∏—è–Ω–∏—è –î–∞–Ω–Ω—ã—Ö](#-–º–µ—Ö–∞–Ω–∏–∑–º—ã-—Å–ª–∏—è–Ω–∏—è-–¥–∞–Ω–Ω—ã—Ö)
4. [–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –°—Ü–µ–Ω–∞—Ä–∏–∏ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è](#-–ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ-—Å—Ü–µ–Ω–∞—Ä–∏–∏-–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)
5. [–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏](#-–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏-–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏)
6. [–°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –£–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ö–æ–Ω—Ñ–ª–∏–∫—Ç–∞–º–∏](#-—Å—Ç—Ä–∞—Ç–µ–≥–∏–∏-—É–ø—Ä–∞–≤–ª–µ–Ω–∏—è-–∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞–º–∏)
7. [–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –í–Ω–µ—à–Ω–∏–º–∏ –°–∏—Å—Ç–µ–º–∞–º–∏](#-–∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è-—Å-–≤–Ω–µ—à–Ω–∏–º–∏-—Å–∏—Å—Ç–µ–º–∞–º–∏)
8. [–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –ê–Ω–∞–ª–∏—Ç–∏–∫–∞](#-–º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥-–∏-–∞–Ω–∞–ª–∏—Ç–∏–∫–∞)

---

## üéØ –í–≤–µ–¥–µ–Ω–∏–µ –≤ Overrides

### –ß—Ç–æ –¢–∞–∫–æ–µ Overrides?

Overrides (–ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è) - —ç—Ç–æ –º–µ—Ö–∞–Ω–∏–∑–º, –ø–æ–∑–≤–æ–ª—è—é—â–∏–π —ç–∫–∑–µ–º–ø–ª—è—Ä–∞–º –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –±–ª–æ–∫–æ–≤ –∏–º–µ—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, –æ—Ç–ª–∏—á–Ω—ã–µ –æ—Ç –º–∞—Å—Ç–µ—Ä-—à–∞–±–ª–æ–Ω–∞, –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –±–ª–æ–∫–∞.

```typescript
// –ú–∞—Å—Ç–µ—Ä-—à–∞–±–ª–æ–Ω (–æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –±–ª–æ–∫)
const masterBlock = {
  id: "hero-template-1",
  content: {
    title: "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!",
    subtitle: "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫",
    backgroundColor: "#ffffff",
    buttonText: "–ü–æ–¥—Ä–æ–±–Ω–µ–µ",
    buttonLink: "/about"
  }
};

// –≠–∫–∑–µ–º–ø–ª—è—Ä —Å –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è–º–∏
const instance = {
  id: "instance-1",
  masterBlockId: "hero-template-1",
  overrides: {
    "title": "–û—Å–æ–±–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ!",
    "backgroundColor": "#f0f8ff",
    "buttonText": "–£–∑–Ω–∞—Ç—å –±–æ–ª—å—à–µ",
    "buttonLink": "/special-offer"
  }
};

// –†–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è overrides
const effectiveContent = {
  title: "–û—Å–æ–±–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ!",        // ‚Üê override –ø—Ä–∏–º–µ–Ω–µ–Ω
  subtitle: "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫", // ‚Üê –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
  backgroundColor: "#f0f8ff",          // ‚Üê override –ø—Ä–∏–º–µ–Ω–µ–Ω
  buttonText: "–£–∑–Ω–∞—Ç—å –±–æ–ª—å—à–µ",         // ‚Üê override –ø—Ä–∏–º–µ–Ω–µ–Ω
  buttonLink: "/special-offer"         // ‚Üê override –ø—Ä–∏–º–µ–Ω–µ–Ω
};
```

### –ó–∞—á–µ–º –ù—É–∂–Ω—ã Overrides?

1. **–ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏—è**: –ö–∞–∂–¥—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –º–æ–∂–µ—Ç –∏–º–µ—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç
2. **–ì–∏–±–∫–æ—Å—Ç—å**: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ –ø–æ–¥ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –Ω—É–∂–¥—ã —Å—Ç—Ä–∞–Ω–∏—Ü—ã
3. **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å**: –û–¥–∏–Ω —à–∞–±–ª–æ–Ω –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ —Ä–∞–∑–Ω—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞—Ö
4. **–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ—Å—Ç—å**: –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –º–∞—Å—Ç–µ—Ä-—à–∞–±–ª–æ–Ω–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∫–æ –≤—Å–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä–∞–º

### –û—Å–Ω–æ–≤–Ω—ã–µ –ö–æ–Ω—Ü–µ–ø—Ü–∏–∏

- **Master Block**: –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —à–∞–±–ª–æ–Ω —Å –±–∞–∑–æ–≤—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
- **Instance**: –≠–∫–∑–µ–º–ø–ª—è—Ä —à–∞–±–ª–æ–Ω–∞ –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
- **Override**: –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å–≤–æ–π—Å—Ç–≤–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞
- **Effective Content**: –§–∏–Ω–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤—Å–µ—Ö overrides
- **Inheritance**: –ù–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤ –æ—Ç –º–∞—Å—Ç–µ—Ä-—à–∞–±–ª–æ–Ω–∞

---

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –°–∏—Å—Ç–µ–º—ã Overrides

### –°—Ç—Ä—É–∫—Ç—É—Ä—ã –î–∞–Ω–Ω—ã—Ö

#### OverrideMap - –û—Å–Ω–æ–≤–Ω–∞—è –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π

```typescript
interface OverrideMap {
  [blockId: string]: {
    [propertyPath: string]: any;
  };
}

// –ü—Ä–∏–º–µ—Ä OverrideMap
const overrides = {
  "hero-title-block": {
    "text": "–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫",
    "style.fontSize": "2rem",
    "style.color": "#0066cc"
  },
  "hero-button-block": {
    "text": "–ö—É–ø–∏—Ç—å —Å–µ–π—á–∞—Å",
    "link": "/purchase",
    "variant": "primary",
    "size": "large"
  },
  "hero-image-block": {
    "src": "/images/special-offer.jpg",
    "alt": "–°–ø–µ—Ü–∏–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ",
    "width": 600,
    "height": 400
  }
};
```

#### –¢–∏–ø—ã Overrides

```typescript
type OverrideValue = string | number | boolean | null | OverrideObject;
type OverrideObject = { [key: string]: OverrideValue };

enum OverrideType {
  // –ü—Ä–æ—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  PRIMITIVE = 'primitive',     // string, number, boolean

  // –°–ª–æ–∂–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
  OBJECT = 'object',          // { key: value }

  // –ú–∞—Å—Å–∏–≤—ã
  ARRAY = 'array',            // [item1, item2, ...]

  // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ç–∏–ø—ã
  REFERENCE = 'reference',    // —Å—Å—ã–ª–∫–∏ –Ω–∞ –¥—Ä—É–≥–∏–µ –±–ª–æ–∫–∏/—Ä–µ—Å—É—Ä—Å—ã
  EXPRESSION = 'expression',  // –≤—ã—á–∏—Å–ª—è–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  CONDITIONAL = 'conditional' // —É—Å–ª–æ–≤–Ω—ã–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
}
```

### –ö–ª–∞—Å—Å OverrideManager

```typescript
class OverrideManager {
  private overrideCache: Map<string, OverrideMap> = new Map();
  private effectiveContentCache: Map<string, any> = new Map();

  /**
   * –ü—Ä–∏–º–µ–Ω—è–µ—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫ –∫–æ–Ω—Ç–µ–Ω—Ç—É –±–ª–æ–∫–∞
   */
  applyOverrides(
    masterContent: any,
    overrides: Record<string, any>,
    options: ApplyOptions = {}
  ): any {
    const cacheKey = this.generateCacheKey(masterContent, overrides, options);

    if (this.effectiveContentCache.has(cacheKey) && !options.skipCache) {
      return this.effectiveContentCache.get(cacheKey);
    }

    const result = this.deepMerge(masterContent, overrides, options);
    this.effectiveContentCache.set(cacheKey, result);

    return result;
  }

  /**
   * –ì–ª—É–±–æ–∫–æ–µ —Å–ª–∏—è–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Ç–∏–ø–æ–≤
   */
  private deepMerge(
    target: any,
    source: Record<string, any>,
    options: ApplyOptions
  ): any {
    // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –≥–ª—É–±–æ–∫–æ–≥–æ —Å–ª–∏—è–Ω–∏—è...
  }

  /**
   * –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π
   */
  validateOverrides(
    overrides: OverrideMap,
    schema: ZodSchema,
    blockStructure: BlockNode[]
  ): ValidationResult {
    // –í–∞–ª–∏–¥–∞—Ü–∏—è overrides –ø–æ —Å—Ö–µ–º–µ...
  }

  /**
   * –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è overrides (—É–¥–∞–ª–µ–Ω–∏–µ –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö)
   */
  optimizeOverrides(
    masterContent: any,
    overrides: Record<string, any>
  ): Record<string, any> {
    // –£–¥–∞–ª–µ–Ω–∏–µ overrides, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç —Å –º–∞—Å—Ç–µ—Ä-–∫–æ–Ω—Ç–µ–Ω—Ç–æ–º...
  }
}

interface ApplyOptions {
  skipCache?: boolean;
  maxDepth?: number;
  allowUndefined?: boolean;
  mergeStrategy?: 'replace' | 'merge' | 'extend';
}
```

---

## üîÑ –ú–µ—Ö–∞–Ω–∏–∑–º—ã –°–ª–∏—è–Ω–∏—è –î–∞–Ω–Ω—ã—Ö

### Deep Merge –ê–ª–≥–æ—Ä–∏—Ç–º

```typescript
/**
 * –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –≥–ª—É–±–æ–∫–æ–≥–æ —Å–ª–∏—è–Ω–∏—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤
 */
function advancedDeepMerge(
  target: any,
  source: Record<string, any>,
  options: MergeOptions = {}
): any {
  const {
    maxDepth = 10,
    currentDepth = 0,
    mergeArrays = false,
    preserveTargetKeys = [],
    transformPaths = {}
  } = options;

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –≥–ª—É–±–∏–Ω—ã
  if (currentDepth >= maxDepth) {
    return source; // –ü—Ä–∏ –≥–ª—É–±–∏–Ω–µ > maxDepth –∏—Å–ø–æ–ª—å–∑—É–µ–º source –∫–∞–∫ –µ—Å—Ç—å
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤
  if (typeof target !== 'object' || target === null) {
    return source;
  }

  if (typeof source !== 'object' || source === null) {
    return source;
  }

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–∞—Å—Å–∏–≤–æ–≤
  if (Array.isArray(target) && Array.isArray(source)) {
    if (mergeArrays) {
      return mergeArraysByStrategy(target, source, options);
    }
    return source; // –ó–∞–º–µ–Ω–∞ –º–∞—Å—Å–∏–≤–∞ —Ü–µ–ª–∏–∫–æ–º
  }

  // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
  const result = Array.isArray(target) ? [] : { ...target };

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–∂–¥–æ–≥–æ –∫–ª—é—á–∞ –∏–∑ source
  for (const [key, sourceValue] of Object.entries(source)) {
    const transformedKey = transformPaths[key] || key;

    // –ü—Ä–æ–ø—É—Å–∫ preserved –∫–ª—é—á–µ–π
    if (preserveTargetKeys.includes(transformedKey)) {
      continue;
    }

    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ —Å–ª–∏—è–Ω–∏–µ –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤
    if (isObject(sourceValue) && isObject(target[transformedKey])) {
      result[transformedKey] = advancedDeepMerge(
        target[transformedKey],
        sourceValue,
        {
          ...options,
          currentDepth: currentDepth + 1
        }
      );
    } else {
      // –ü—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞
      result[transformedKey] = sourceValue;
    }
  }

  return result;
}

function mergeArraysByStrategy(
  target: any[],
  source: any[],
  options: MergeOptions
): any[] {
  const { arrayMergeStrategy = 'replace' } = options;

  switch (arrayMergeStrategy) {
    case 'concat':
      return [...target, ...source];

    case 'merge-by-index':
      return source.map((item, index) =>
        index < target.length
          ? advancedDeepMerge(target[index], item, options)
          : item
      );

    case 'merge-by-key':
      const targetMap = new Map(target.map(item => [getMergeKey(item), item]));
      return source.map(sourceItem => {
        const key = getMergeKey(sourceItem);
        const targetItem = targetMap.get(key);
        return targetItem
          ? advancedDeepMerge(targetItem, sourceItem, options)
          : sourceItem;
      });

    case 'replace':
    default:
      return [...source];
  }
}
```

### –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –¢–∏–ø—ã Overrides

#### 1. Conditional Overrides (–£—Å–ª–æ–≤–Ω—ã–µ –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è)

```typescript
interface ConditionalOverride {
  type: 'conditional';
  condition: {
    field: string;        // –ø–æ–ª–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
    operator: 'equals' | 'contains' | 'greater' | 'less';
    value: any;          // –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
  };
  value: any;            // –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ —É—Å–ª–æ–≤–∏—è
  fallback?: any;        // –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ –Ω–µ–≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ —É—Å–ª–æ–≤–∏—è
}

// –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
const conditionalOverrides = {
  "button.variant": {
    type: 'conditional',
    condition: {
      field: 'user.isPremium',
      operator: 'equals',
      value: true
    },
    value: 'premium',
    fallback: 'standard'
  }
};
```

#### 2. Expression Overrides (–í—ã—á–∏—Å–ª—è–µ–º—ã–µ –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è)

```typescript
interface ExpressionOverride {
  type: 'expression';
  expression: string;    // JavaScript –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
  context: string[];     // –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
}

// –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
const expressionOverrides = {
  "discount.percentage": {
    type: 'expression',
    expression: "Math.min(user.purchaseHistory.length * 5, 25)",
    context: ['user', 'page']
  }
};
```

#### 3. Reference Overrides (–°—Å—ã–ª–æ—á–Ω—ã–µ –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è)

```typescript
interface ReferenceOverride {
  type: 'reference';
  reference: {
    type: 'block' | 'global' | 'context';
    id: string;
    path?: string;      // –ø—É—Ç—å –∫ —Å–≤–æ–π—Å—Ç–≤—É –≤ referenced –æ–±—ä–µ–∫—Ç–µ
  };
}

// –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
const referenceOverrides = {
  "button.link": {
    type: 'reference',
    reference: {
      type: 'global',
      id: 'currentCampaign',
      path: 'landingPage'
    }
  }
};
```

---

## üöÄ –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–µ –°—Ü–µ–Ω–∞—Ä–∏–∏ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

### –°—Ü–µ–Ω–∞—Ä–∏–π 1: –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–µ Overrides

```typescript
// –ú–∞—Å—Ç–µ—Ä-—à–∞–±–ª–æ–Ω
const masterHeroBlock = {
  content: {
    layout: {
      backgroundColor: "#ffffff",
      padding: "2rem",
      borderRadius: "8px"
    },
    title: {
      text: "–ó–∞–≥–æ–ª–æ–≤–æ–∫",
      style: {
        fontSize: "2rem",
        color: "#333333"
      }
    },
    button: {
      text: "–ö–Ω–æ–ø–∫–∞",
      variant: "primary",
      size: "medium"
    }
  }
};

// –≠–∫–∑–µ–º–ø–ª—è—Ä —Å –º–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–º–∏ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è–º–∏
const instanceOverrides = {
  // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç–æ–≥–æ —Å–≤–æ–π—Å—Ç–≤–∞
  "title.text": "–ú–æ–π –∑–∞–≥–æ–ª–æ–≤–æ–∫",

  // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
  "title.style": {
    fontSize: "2.5rem",
    color: "#0066cc",
    fontWeight: "bold"
  },

  // –ß–∞—Å—Ç–∏—á–Ω–æ–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞
  "layout.backgroundColor": "#f8f9ff",

  // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –¥—Ä—É–≥–∏—Ö —Å–≤–æ–π—Å—Ç–≤
  "button": {
    text: "–ú–æ—è –∫–Ω–æ–ø–∫–∞",
    // variant –∏ size –æ—Å—Ç–∞—é—Ç—Å—è –∏–∑ –º–∞—Å—Ç–µ—Ä-—à–∞–±–ª–æ–Ω–∞
  }
};
```

### –°—Ü–µ–Ω–∞—Ä–∏–π 2: –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ-–∑–∞–≤–∏—Å–∏–º—ã–µ Overrides

```typescript
// –°–∏—Å—Ç–µ–º–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
interface PageContext {
  user: {
    id: string;
    role: string;
    preferences: Record<string, any>;
  };
  page: {
    type: string;
    category: string;
    tags: string[];
  };
  campaign: {
    id: string;
    theme: string;
    active: boolean;
  };
}

// –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ-–∑–∞–≤–∏—Å–∏–º—ã–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
const contextualOverrides = {
  // –ó–∞–≤–∏—Å–∏—Ç –æ—Ç —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  "hero.title": {
    type: 'conditional',
    condition: {
      field: 'user.role',
      operator: 'equals',
      value: 'premium'
    },
    value: "–ü—Ä–µ–º–∏—É–º –∫–æ–Ω—Ç–µ–Ω—Ç",
    fallback: "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç"
  },

  // –ó–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–∏–ø–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
  "hero.backgroundColor": {
    type: 'conditional',
    condition: {
      field: 'page.type',
      operator: 'equals',
      value: 'landing'
    },
    value: "#ff6b6b",
    fallback: "#4ecdc4"
  },

  // –ó–∞–≤–∏—Å–∏—Ç –æ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –∫–∞–º–ø–∞–Ω–∏–∏
  "cta.button.text": {
    type: 'reference',
    reference: {
      type: 'context',
      id: 'campaign',
      path: 'ctaText'
    }
  }
};
```

### –°—Ü–µ–Ω–∞—Ä–∏–π 3: –ö–∞—Å–∫–∞–¥–Ω—ã–µ Overrides

```typescript
// –ö–∞—Å–∫–∞–¥–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π
class CascadingOverrideManager {
  private overrideLayers: OverrideLayer[] = [];

  addLayer(layer: OverrideLayer): void {
    this.overrideLayers.push(layer);
    this.sortLayersByPriority();
  }

  applyCascadingOverrides(masterContent: any): any {
    let result = { ...masterContent };

    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–ª–æ–∏ –≤ –ø–æ—Ä—è–¥–∫–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
    for (const layer of this.overrideLayers) {
      if (this.shouldApplyLayer(layer)) {
        result = advancedDeepMerge(result, layer.overrides, layer.options);
      }
    }

    return result;
  }

  private shouldApplyLayer(layer: OverrideLayer): boolean {
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Å–ª–æ—è
    if (layer.condition) {
      return this.evaluateCondition(layer.condition);
    }
    return true;
  }
}

interface OverrideLayer {
  id: string;
  name: string;
  priority: number;           // –ø–æ—Ä—è–¥–æ–∫ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è (–º–µ–Ω—å—à–µ = —Ä–∞–Ω—å—à–µ)
  overrides: OverrideMap;
  condition?: OverrideCondition;
  options?: MergeOptions;
}
```

---

## ‚ö° –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

### –ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ Overrides

```typescript
class OverrideCache {
  private cache = new Map<string, CachedOverrideResult>();
  private readonly ttl = 5 * 60 * 1000; // 5 –º–∏–Ω—É—Ç

  get(cacheKey: string): CachedOverrideResult | null {
    const cached = this.cache.get(cacheKey);
    if (!cached) return null;

    if (Date.now() - cached.timestamp > this.ttl) {
      this.cache.delete(cacheKey);
      return null;
    }

    return cached;
  }

  set(cacheKey: string, result: any, metadata: CacheMetadata): void {
    this.cache.set(cacheKey, {
      result,
      metadata,
      timestamp: Date.now()
    });
  }

  invalidate(pattern: string): void {
    for (const [key] of this.cache) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
      }
    }
  }

  // –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –∑–∞–ø–∏—Å–µ–π
  cleanup(): void {
    const now = Date.now();
    for (const [key, cached] of this.cache) {
      if (now - cached.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
  }
}

interface CachedOverrideResult {
  result: any;
  metadata: CacheMetadata;
  timestamp: number;
}

interface CacheMetadata {
  masterVersion: number;
  overrideVersion: number;
  computationTime: number;
  hitCount: number;
}
```

### –õ–µ–Ω–∏–≤–æ–µ –í—ã—á–∏—Å–ª–µ–Ω–∏–µ

```typescript
class LazyOverrideResolver {
  private computedValues = new Map<string, Promise<any>>();
  private resolver = new OverrideResolver();

  async resolveOverride(
    blockId: string,
    propertyPath: string,
    context: ResolutionContext
  ): Promise<any> {
    const cacheKey = `${blockId}:${propertyPath}:${context.version}`;

    if (this.computedValues.has(cacheKey)) {
      return this.computedValues.get(cacheKey)!;
    }

    // –°–æ–∑–¥–∞–µ–º promise –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è
    const computation = this.performResolution(blockId, propertyPath, context);
    this.computedValues.set(cacheKey, computation);

    // –û—á–∏—Å—Ç–∫–∞ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    computation.finally(() => {
      this.computedValues.delete(cacheKey);
    });

    return computation;
  }

  private async performResolution(
    blockId: string,
    propertyPath: string,
    context: ResolutionContext
  ): Promise<any> {
    // –ò–º–∏—Ç–∞—Ü–∏—è —Ç—è–∂–µ–ª–æ–≥–æ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è
    await new Promise(resolve => setTimeout(resolve, 100));

    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ override
    return this.resolver.resolve(blockId, propertyPath, context);
  }
}
```

### Batch Processing

```typescript
class BatchOverrideProcessor {
  private batchQueue: OverrideBatch[] = [];
  private processing = false;

  async addToBatch(overrideRequest: OverrideRequest): Promise<any> {
    return new Promise((resolve, reject) => {
      this.batchQueue.push({
        request: overrideRequest,
        resolve,
        reject
      });

      this.processBatchIfNeeded();
    });
  }

  private async processBatchIfNeeded(): Promise<void> {
    if (this.processing || this.batchQueue.length < 10) {
      return;
    }

    this.processing = true;

    try {
      const batch = this.batchQueue.splice(0, 50); // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ 50 –∑–∞–ø—Ä–æ—Å–æ–≤
      const results = await this.processBatch(batch.map(b => b.request));

      // –†–∞–∑—Ä–µ—à–∞–µ–º promises
      batch.forEach((item, index) => {
        item.resolve(results[index]);
      });
    } catch (error) {
      // –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –æ—Ç–∫–ª–æ–Ω—è–µ–º –≤—Å–µ promises –≤ –±–∞—Ç—á–µ
      this.batchQueue.forEach(item => {
        item.reject(error);
      });
      this.batchQueue = [];
    } finally {
      this.processing = false;
    }
  }

  private async processBatch(requests: OverrideRequest[]): Promise<any[]> {
    // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ –ø–æ –º–∞—Å—Ç–µ—Ä-–±–ª–æ–∫–∞–º –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    const grouped = this.groupByMasterBlock(requests);

    // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≥—Ä—É–ø–ø
    const promises = Object.values(grouped).map(group =>
      this.processMasterBlockGroup(group)
    );

    const results = await Promise.all(promises);
    return results.flat();
  }
}
```

---

## ‚öîÔ∏è –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –£–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ö–æ–Ω—Ñ–ª–∏–∫—Ç–∞–º–∏

### –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –ö–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤

```typescript
interface OverrideConflict {
  blockId: string;
  propertyPath: string;
  masterValue: any;
  overrideValue: any;
  conflictType: ConflictType;
  severity: 'low' | 'medium' | 'high';
  suggestedResolution: ConflictResolution;
}

enum ConflictType {
  TYPE_MISMATCH = 'type_mismatch',
  SCHEMA_VIOLATION = 'schema_violation',
  DEPENDENCY_CONFLICT = 'dependency_conflict',
  CIRCULAR_REFERENCE = 'circular_reference',
  PERFORMANCE_IMPACT = 'performance_impact'
}

class ConflictDetector {
  detectConflicts(
    masterContent: any,
    overrides: OverrideMap,
    schema?: ZodSchema
  ): OverrideConflict[] {
    const conflicts: OverrideConflict[] = [];

    for (const [blockId, blockOverrides] of Object.entries(overrides)) {
      conflicts.push(...this.detectBlockConflicts(
        blockId,
        masterContent,
        blockOverrides,
        schema
      ));
    }

    return conflicts;
  }

  private detectBlockConflicts(
    blockId: string,
    masterContent: any,
    overrides: Record<string, any>,
    schema?: ZodSchema
  ): OverrideConflict[] {
    const conflicts: OverrideConflict[] = [];

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–æ–≤
    for (const [path, overrideValue] of Object.entries(overrides)) {
      const masterValue = getNestedProperty(masterContent, path);

      if (this.hasTypeConflict(masterValue, overrideValue)) {
        conflicts.push({
          blockId,
          propertyPath: path,
          masterValue,
          overrideValue,
          conflictType: ConflictType.TYPE_MISMATCH,
          severity: 'high',
          suggestedResolution: {
            action: 'convert_type',
            targetType: typeof masterValue,
            description: `Convert override value to match master type: ${typeof masterValue}`
          }
        });
      }

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ö–µ–º—ã
      if (schema && this.violatesSchema(path, overrideValue, schema)) {
        conflicts.push({
          blockId,
          propertyPath: path,
          masterValue,
          overrideValue,
          conflictType: ConflictType.SCHEMA_VIOLATION,
          severity: 'high',
          suggestedResolution: {
            action: 'fix_schema',
            description: 'Override violates schema constraints'
          }
        });
      }
    }

    return conflicts;
  }
}
```

### –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –ö–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤

```typescript
class ConflictResolver {
  resolveConflicts(
    conflicts: OverrideConflict[],
    resolutionStrategy: ResolutionStrategy = 'interactive'
  ): ConflictResolution[] {
    const resolutions: ConflictResolution[] = [];

    for (const conflict of conflicts) {
      const resolution = this.resolveConflict(conflict, resolutionStrategy);
      resolutions.push(resolution);
    }

    return resolutions;
  }

  private resolveConflict(
    conflict: OverrideConflict,
    strategy: ResolutionStrategy
  ): ConflictResolution {
    switch (strategy) {
      case 'master_wins':
        return {
          action: 'remove_override',
          description: 'Remove conflicting override, keep master value'
        };

      case 'override_wins':
        return {
          action: 'keep_override',
          description: 'Keep override value, ignore type/schema issues'
        };

      case 'convert_value':
        return {
          action: 'convert_type',
          targetType: typeof conflict.masterValue,
          description: 'Attempt to convert override value to master type'
        };

      case 'interactive':
      default:
        return {
          action: 'prompt_user',
          description: 'Show conflict to user for manual resolution'
        };
    }
  }

  async applyResolutions(
    overrides: OverrideMap,
    resolutions: ConflictResolution[]
  ): Promise<OverrideMap> {
    let result = { ...overrides };

    for (const resolution of resolutions) {
      result = await this.applyResolution(result, resolution);
    }

    return result;
  }
}
```

### –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –ö–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤

```typescript
class OverrideValidator {
  private validators: Map<string, OverrideValidatorFn> = new Map();

  registerValidator(propertyPath: string, validator: OverrideValidatorFn): void {
    this.validators.set(propertyPath, validator);
  }

  validateOverride(
    propertyPath: string,
    value: any,
    context: ValidationContext
  ): ValidationResult {
    const validator = this.validators.get(propertyPath);

    if (!validator) {
      return { isValid: true };
    }

    try {
      return validator(value, context);
    } catch (error) {
      return {
        isValid: false,
        error: error.message,
        suggestions: this.generateSuggestions(propertyPath, value, error)
      };
    }
  }

  private generateSuggestions(
    propertyPath: string,
    value: any,
    error: Error
  ): ValidationSuggestion[] {
    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –ø–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—é override
    return [
      {
        type: 'fix_type',
        description: `Change type to ${this.inferCorrectType(propertyPath)}`,
        fix: this.generateTypeFix(propertyPath, value)
      },
      {
        type: 'use_default',
        description: 'Use default value from master block',
        fix: this.getDefaultValue(propertyPath)
      }
    ];
  }
}
```

---

## üîó –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –í–Ω–µ—à–Ω–∏–º–∏ –°–∏—Å—Ç–µ–º–∞–º–∏

### CMS Integration

```typescript
class CMSIntegrationManager {
  private cmsAdapter: CMSAdapter;

  async syncOverridesWithCMS(
    instanceId: string,
    overrides: OverrideMap
  ): Promise<void> {
    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å CMS
    await this.cmsAdapter.updateBlockInstance(instanceId, {
      overrides: JSON.stringify(overrides),
      lastSync: new Date().toISOString()
    });
  }

  async importOverridesFromCMS(instanceId: string): Promise<OverrideMap> {
    const cmsData = await this.cmsAdapter.getBlockInstance(instanceId);
    return JSON.parse(cmsData.overrides || '{}');
  }

  async handleCMSEvents(event: CMSEvent): Promise<void> {
    switch (event.type) {
      case 'block_updated':
        await this.handleBlockUpdate(event.data);
        break;
      case 'instance_deleted':
        await this.handleInstanceDeletion(event.data);
        break;
      case 'master_block_changed':
        await this.handleMasterBlockChange(event.data);
        break;
    }
  }
}
```

### External API Integration

```typescript
class ExternalAPIIntegration {
  private apiClients: Map<string, APIClient> = new Map();

  registerAPIClient(name: string, client: APIClient): void {
    this.apiClients.set(name, client);
  }

  async resolveExternalReference(
    reference: ExternalReference,
    context: ResolutionContext
  ): Promise<any> {
    const client = this.apiClients.get(reference.apiName);
    if (!client) {
      throw new Error(`API client not found: ${reference.apiName}`);
    }

    return await client.fetch(reference.endpoint, {
      params: reference.params,
      headers: this.buildAuthHeaders(context)
    });
  }

  private buildAuthHeaders(context: ResolutionContext): Record<string, string> {
    // –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
    return {
      'Authorization': `Bearer ${context.apiToken}`,
      'X-API-Key': context.apiKey
    };
  }
}

interface ExternalReference {
  apiName: string;
  endpoint: string;
  params: Record<string, any>;
  cache?: {
    ttl: number;
    key: string;
  };
}
```

### Content Management System Integration

```typescript
class ContentManagementIntegration {
  private cmsSystems: Map<string, CMSConnector> = new Map();

  async exportOverridesToCMS(
    systemName: string,
    instanceId: string,
    overrides: OverrideMap
  ): Promise<void> {
    const cms = this.cmsSystems.get(systemName);
    if (!cms) {
      throw new Error(`CMS system not found: ${systemName}`);
    }

    const cmsOverrides = this.transformOverridesForCMS(overrides, cms.schema);
    await cms.updateContent(instanceId, cmsOverrides);
  }

  async importOverridesFromCMS(
    systemName: string,
    contentId: string
  ): Promise<OverrideMap> {
    const cms = this.cmsSystems.get(systemName);
    if (!cms) {
      throw new Error(`CMS system not found: ${systemName}`);
    }

    const cmsContent = await cms.getContent(contentId);
    return this.transformCMSContentToOverrides(cmsContent);
  }

  private transformOverridesForCMS(
    overrides: OverrideMap,
    cmsSchema: CMSSchema
  ): any {
    // –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è overrides –≤ —Ñ–æ—Ä–º–∞—Ç CMS
    const transformed: any = {};

    for (const [blockId, blockOverrides] of Object.entries(overrides)) {
      const cmsBlockId = this.mapBlockIdToCMS(blockId, cmsSchema);
      transformed[cmsBlockId] = {};

      for (const [path, value] of Object.entries(blockOverrides)) {
        const cmsPath = this.mapPropertyPathToCMS(path, cmsSchema);
        transformed[cmsBlockId][cmsPath] = value;
      }
    }

    return transformed;
  }
}
```

---

## üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –ê–Ω–∞–ª–∏—Ç–∏–∫–∞

### –ú–µ—Ç—Ä–∏–∫–∏ Overrides

```typescript
interface OverrideMetrics {
  // –û–±—â–∏–µ –º–µ—Ç—Ä–∏–∫–∏
  totalOverrides: number;
  activeInstances: number;
  cacheHitRate: number;

  // –ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
  averageResolutionTime: number;
  maxResolutionTime: number;
  resolutionTimePercentiles: {
    p50: number;
    p95: number;
    p99: number;
  };

  // –ú–µ—Ç—Ä–∏–∫–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
  mostUsedProperties: Array<{
    property: string;
    usageCount: number;
    averageValue: any;
  }>;

  // –ú–µ—Ç—Ä–∏–∫–∏ –æ—à–∏–±–æ–∫
  conflictCount: number;
  resolutionSuccessRate: number;
  commonConflictTypes: Array<{
    type: ConflictType;
    count: number;
    percentage: number;
  }>;

  // –ú–µ—Ç—Ä–∏–∫–∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
  overridesByHour: Array<{
    hour: number;
    count: number;
  }>;
  overridesByDay: Array<{
    date: string;
    count: number;
  }>;
}

class OverrideAnalytics {
  private metrics: OverrideMetrics;
  private eventBuffer: OverrideEvent[] = [];

  recordEvent(event: OverrideEvent): void {
    this.eventBuffer.push(event);

    // –ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞–∂–¥—ã–µ 100 —Å–æ–±—ã—Ç–∏–π
    if (this.eventBuffer.length >= 100) {
      this.processEvents();
    }
  }

  async getMetrics(
    timeRange: TimeRange = { hours: 24 }
  ): Promise<OverrideMetrics> {
    return await this.calculateMetrics(timeRange);
  }

  async generateReport(
    timeRange: TimeRange,
    format: 'json' | 'csv' | 'pdf' = 'json'
  ): Promise<ReportData> {
    const metrics = await this.getMetrics(timeRange);

    switch (format) {
      case 'json':
        return this.generateJSONReport(metrics);
      case 'csv':
        return this.generateCSVReport(metrics);
      case 'pdf':
        return this.generatePDFReport(metrics);
    }
  }

  private async processEvents(): Promise<void> {
    const events = [...this.eventBuffer];
    this.eventBuffer = [];

    // –ü–∞–∫–µ—Ç–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
    await this.updateMetrics(events);
  }

  private async calculateMetrics(timeRange: TimeRange): Promise<OverrideMetrics> {
    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    const [
      totalOverrides,
      activeInstances,
      performanceData,
      usageData,
      conflictData
    ] = await Promise.all([
      this.getTotalOverrides(timeRange),
      this.getActiveInstances(timeRange),
      this.getPerformanceMetrics(timeRange),
      this.getUsageMetrics(timeRange),
      this.getConflictMetrics(timeRange)
    ]);

    return {
      totalOverrides,
      activeInstances,
      cacheHitRate: performanceData.cacheHitRate,
      averageResolutionTime: performanceData.averageTime,
      maxResolutionTime: performanceData.maxTime,
      resolutionTimePercentiles: performanceData.percentiles,
      mostUsedProperties: usageData.topProperties,
      conflictCount: conflictData.totalConflicts,
      resolutionSuccessRate: conflictData.successRate,
      commonConflictTypes: conflictData.conflictTypes,
      overridesByHour: await this.getOverridesByHour(timeRange),
      overridesByDay: await this.getOverridesByDay(timeRange)
    };
  }

  private async updateMetrics(events: OverrideEvent[]): Promise<void> {
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    const updates = events.map(event => ({
      type: event.type,
      timestamp: event.timestamp,
      data: event.data
    }));

    await this.bulkUpdateMetrics(updates);
  }
}
```

### –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

```typescript
class OverridePerformanceMonitor {
  private metrics: Map<string, PerformanceData> = new Map();

  startTracking(operationId: string): PerformanceTracker {
    const tracker = new PerformanceTracker(operationId);
    this.metrics.set(operationId, {
      startTime: Date.now(),
      operationType: 'override_resolution',
      tracker
    });
    return tracker;
  }

  recordMetric(
    operationId: string,
    metric: PerformanceMetric,
    value: number
  ): void {
    const data = this.metrics.get(operationId);
    if (data) {
      data[metric] = value;
    }
  }

  endTracking(operationId: string): PerformanceData {
    const data = this.metrics.get(operationId);
    if (!data) {
      throw new Error(`No tracking data for operation: ${operationId}`);
    }

    data.endTime = Date.now();
    data.duration = data.endTime - data.startTime;

    // –û—Ç–ø—Ä–∞–≤–∫–∞ –º–µ—Ç—Ä–∏–∫ –≤ —Å–∏—Å—Ç–µ–º—É –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
    this.sendToMonitoring(data);

    // –û—á–∏—Å—Ç–∫–∞
    this.metrics.delete(operationId);

    return data;
  }

  private async sendToMonitoring(data: PerformanceData): Promise<void> {
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ —Å–∏—Å—Ç–µ–º—É –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ (DataDog, CloudWatch, etc.)
    await monitoringClient.sendMetric({
      name: 'override_resolution_time',
      value: data.duration,
      tags: {
        operation_type: data.operationType,
        success: data.success ? 'true' : 'false'
      }
    });
  }

  getSlowOperations(threshold: number = 1000): PerformanceData[] {
    return Array.from(this.metrics.values())
      .filter(data => data.duration && data.duration > threshold);
  }
}
```

### Alerting System

```typescript
class OverrideAlertingSystem {
  private alerts: AlertRule[] = [];

  addAlertRule(rule: AlertRule): void {
    this.alerts.push(rule);
  }

  async checkAlerts(metrics: OverrideMetrics): Promise<Alert[]> {
    const triggeredAlerts: Alert[] = [];

    for (const rule of this.alerts) {
      if (this.evaluateRule(rule, metrics)) {
        triggeredAlerts.push({
          id: generateId(),
          ruleId: rule.id,
          severity: rule.severity,
          message: this.buildAlertMessage(rule, metrics),
          timestamp: new Date(),
          metrics: this.extractRelevantMetrics(rule, metrics)
        });
      }
    }

    // –û—Ç–ø—Ä–∞–≤–∫–∞ –∞–ª–µ—Ä—Ç–æ–≤
    await this.sendAlerts(triggeredAlerts);

    return triggeredAlerts;
  }

  private evaluateRule(rule: AlertRule, metrics: OverrideMetrics): boolean {
    switch (rule.type) {
      case 'threshold':
        return this.checkThreshold(rule, metrics);

      case 'trend':
        return this.checkTrend(rule, metrics);

      case 'anomaly':
        return this.checkAnomaly(rule, metrics);

      default:
        return false;
    }
  }

  private checkThreshold(rule: ThresholdAlert, metrics: OverrideMetrics): boolean {
    const value = this.getMetricValue(rule.metric, metrics);
    return rule.operator === 'gt' ? value > rule.threshold : value < rule.threshold;
  }

  private async sendAlerts(alerts: Alert[]): Promise<void> {
    // –û—Ç–ø—Ä–∞–≤–∫–∞ –∞–ª–µ—Ä—Ç–æ–≤ —á–µ—Ä–µ–∑ —Ä–∞–∑–ª–∏—á–Ω—ã–µ –∫–∞–Ω–∞–ª—ã
    await Promise.all([
      this.sendEmailAlerts(alerts),
      this.sendSlackAlerts(alerts),
      this.sendPagerDutyAlerts(alerts.filter(a => a.severity === 'critical'))
    ]);
  }
}

interface AlertRule {
  id: string;
  name: string;
  type: 'threshold' | 'trend' | 'anomaly';
  severity: 'low' | 'medium' | 'high' | 'critical';
  enabled: boolean;
}

interface ThresholdAlert extends AlertRule {
  type: 'threshold';
  metric: string;
  operator: 'gt' | 'lt';
  threshold: number;
}
```

---

## üéØ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–°–∏—Å—Ç–µ–º–∞ overrides –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Å–ª–æ–∂–Ω—É—é –∏ –º–æ—â–Ω—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º –≤ CMS. –í–æ—Ç –∫–ª—é—á–µ–≤—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è:

### üèÜ –ö–ª—é—á–µ–≤—ã–µ –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:

1. **–ì–∏–±–∫–∞—è –°–∏—Å—Ç–µ–º–∞ –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π**:
   - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø—Ä–æ—Å—Ç—ã—Ö –∏ —Å–ª–æ–∂–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö
   - –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–µ –∏ –∫–∞—Å–∫–∞–¥–Ω—ã–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
   - –£—Å–ª–æ–≤–Ω—ã–µ –∏ –≤—ã—á–∏—Å–ª—è–µ–º—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è

2. **–í—ã—Å–æ–∫–∞—è –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**:
   - –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ
   - –õ–µ–Ω–∏–≤—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∏ batch processing
   - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã —Å–ª–∏—è–Ω–∏—è

3. **–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å –∏ –ö–∞—á–µ—Å—Ç–≤–æ**:
   - –ö–æ–º–ø–ª–µ–∫—Å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
   - –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤
   - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ

4. **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å**:
   - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –≤–Ω–µ—à–Ω–∏—Ö API
   - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å CMS —Å–∏—Å—Ç–µ–º–∞–º–∏
   - –†–∞—Å—à–∏—Ä—è–µ–º–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

### üîÆ –ë—É–¥—É—â–∏–µ –£–ª—É—á—à–µ–Ω–∏—è:

1. **AI-Powered Overrides**: –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π
2. **Real-time Collaboration**: –°–æ–≤–º–µ—Å—Ç–Ω–æ–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ overrides
3. **Advanced Analytics**: –ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
4. **Version Control**: –°–∏—Å—Ç–µ–º–∞ –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è overrides

### üìä –ú–µ—Ç—Ä–∏–∫–∏ –£—Å–ø–µ—Ö–∞:

- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: < 100ms —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è overrides
- **–ù–∞–¥–µ–∂–Ω–æ—Å—Ç—å**: > 99.9% —É—Å–ø–µ—à–Ω—ã—Ö —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π
- **–£–¥–æ–±—Å—Ç–≤–æ**: < 30 —Å–µ–∫—É–Ω–¥ –Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫—É —Ç–∏–ø–∏—á–Ω–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞
- **–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å**: –ü–æ–¥–¥–µ—Ä–∂–∫–∞ 10k+ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π

–°–∏—Å—Ç–µ–º–∞ overrides —è–≤–ª—è–µ—Ç—Å—è —Å–µ—Ä–¥—Ü–µ–º –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –≥–∏–±–∫–æ—Å—Ç—å, –Ω–µ–æ–±—Ö–æ–¥–∏–º—É—é –¥–ª—è —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö CMS —Ä–µ—à–µ–Ω–∏–π.
